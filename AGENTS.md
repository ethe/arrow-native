# Compile-Time Arrow Schema (arrow-rs) — Plan & Design

## TL;DR
- Provide a compile-time schema for Arrow using Rust types and macros.
- Generate monomorphized code per column index and base type (no runtime `DataType` switching).
- Bridge type-level schema to arrow-rs builders/arrays and to a runtime `Schema`/`RecordBatch` when needed.

---

## Goals
- Encode each column’s Arrow type and nullability at the type level via `#[derive(Record)]`.
- Enable compile-time dispatch across columns and base types using traits/const-generics (no `match DataType` at runtime).
- Generate typed Arrow builders/arrays for each column from the compile-time schema.
- Produce a runtime `arrow_schema::Schema` and `RecordBatch` from the compile-time schema when integration with arrow-rs is needed.
- Keep ergonomics close to idiomatic Rust: field attributes express Arrow specifics; Option/Nullability is explicit.

## Non-Goals (Initial Phases)
- Full coverage of every Arrow type (lists, maps, unions, dense nested). We start with primitives, bool, utf8, binary, timestamp(UTC), decimal128.
- Transparent timezone strings at the type level. We’ll start with UTC-only timestamps, expand later.
- Runtime reflection of arbitrary user types. The schema is compile-time and explicit.

---

## High-Level Architecture

### Type-Level Schema (Core)
- `#[derive(Record)]` on a plain Rust struct generates:
  - `impl Record for T` with `const LEN: usize`.
  - Per-column type metadata via `ColAt<I>` exposing `type Rust`, `type ColumnBuilder`, `type ColumnArray`, `const NULLABLE`, `const NAME`, and `fn data_type() -> DataType`.
  - A type-directed “for-each column” expansion hook via `ForEachCol::for_each_col`.

- Implemented traits (current):
  - `Record`, `ColAt<I>`, `ForEachCol`.
  - Row-based building: `BuildRows` with generated `<Type>Builders` and `<Type>Arrays`.
  - Nested struct support: `StructMeta` (child fields + struct builder) and `AppendStruct` (append children into a StructBuilder).

- Nullability:
  - Mode A: Use `Option<T>` in the field type.
  - Mode B: `#[arrow(nullable)]` attribute even if field type is non-`Option` (explicit override). Derived code maps to `NULLABLE` const.

### Arrow Interop (Runtime Bridge)
- Type mapping trait:
  - `trait ArrowBinding { type Builder; type Array: arrow_array::Array; fn data_type() -> DataType; ... }`
  - Implementations map Rust types directly to arrow-rs typed builders/arrays without runtime dispatch.

- Builders API (row-based):
  - `BuildRows` derive emits `<Type>Builders` and `<Type>Arrays`.
  - `<Type>Builders` methods: `append_row(row)`, `append_rows(iter)`, `append_null_row()`, `append_option_row(Option<row>)`, `append_option_rows(iter)`; `finish()` returns `<Type>Arrays`.
  - Nested structs are supported via `#[arrow(nested)]`/`#[nested]` and `AppendStruct`.
  - Future: optional `into_record_batch()` bridge when needed.

- Runtime schema:
  - Planned: `schema::<R>()` from `ColAt<I>`/`StructMeta` when integrating with RecordBatch.

- Compile-Time Dispatch (No runtime matches)
- Column visitor/iterator (generated by derive):
  - `trait ColumnVisitor { fn visit<const I: usize, R>(FieldMeta<R>); }`
  - `for_each_col::<V>()` expands to `V::visit::<I, Rust>(...)` for each column at compile time.
- Kernel pattern: implement `ColumnVisitor` for an operation; the monomorphized instances per column/base-type fall out of generics.

- Macro & Attribute Design
- `#[derive(Record)]` with field-level attributes:
  - `#[arrow(nested)]` or `#[nested]` marks a struct-typed field as a nested `Struct` for row-based append ergonomics.
  - Future: `#[arrow(list(large = bool))]`, `#[arrow(map(keys_sorted = bool))]`, decimal/timestamp attributes if we add schema-only overrides.
- Helper macro for column iteration (optional if derive emits trait impl):
  - `for_each_col!(RecordType, |I, Meta| { /* compile-time expanded body */ });`

### Ergonomics
- Default mapping for well-known Rust types:
  - `i8/i16/i32/i64`, `u8/u16/u32/u64`, `f32/f64`, `bool` map to Arrow primitives.
  - `String` → `Utf8`, `Vec<u8>` → `Binary`.
  - `Option<T>` toggles nullability at the column level.
- Nested & specialized wrappers (current):
  - Lists: `List<T>` (items non-null), `ListNullable<T>` (items nullable).
  - Dictionary: `Dictionary<K, String>` (Utf8 values; integer keys).
  - Timestamp: `Timestamp<U>` with unit markers (`Second`, `Millisecond`, `Microsecond`, `Nanosecond`).
  - Structs: nested structs via `#[arrow(nested)]`/`#[nested]` and row-based append.

---

## Example

```rust
use arrow_native::prelude::*;

#[derive(Record)]
struct Address { city: String, zip: Option<i32> }

#[derive(Record)]
struct Person {
    id: i64,
    #[arrow(nested)]
    address: Option<Address>,
    email: Option<String>,
}

fn build_arrays_from_rows(rows: Vec<Option<Person>>) {
    let mut b = <Person as BuildRows>::new_builders(rows.len());
    b.append_option_rows(rows);
    let arrays = b.finish();
    // arrays.id: PrimitiveArray<Int64Type>
    // arrays.address: StructArray
    // arrays.email: StringArray
}

// Example compile-time dispatch
struct Count;
impl ColumnVisitor for Count {
    fn visit<const I: usize, R>(_m: FieldMeta<R>) {
        let _ = I;
    }
}
fn debug_schema<T: ForEachCol>() { T::for_each_col::<Count>(); }
```

---

## Implementation Plan

### Crate Layout
- `crates/core` — traits, markers, prelude, runtime bridge shims.
- `crates/derive` — `#[derive(Record)]` proc-macro, attributes parsing, codegen.
- `crates/examples` — small end-to-end demos, doctests.

### Phase 0 — Scaffolding
- Set up workspace, feature flags, MSRV, CI.
- Add `ArrowMarker` set and `ArrowNative` mapping traits with initial impls.

### Phase 1 — Primitives + Utf8 + Bool
- Derive(Record) generates: `Record`, `ColAt<I>`, `ForEachCol`.
- Implement ArrowBinding for primitives; expose associated ColumnBuilder/Array via `ColAt<I>`.
- Tests: `LEN`, names, types, builders/arrays.

### Phase 2 — Temporal + Binary
- Add `Timestamp<U>` (Second/Millisecond/Microsecond/Nanosecond) and `Binary`.
- Mapping to arrow-rs arrays/builders and to runtime `DataType`.
- Tests: temporal behavior and schema.

### Phase 3 — Compile-Time Dispatch Utilities
- `ColumnVisitor` and `ForEachCol` expansion emitted by derive.
- Example kernels with full monomorphization.

### Phase 4 — Ergonomics & Docs
- Attribute polish (`#[arrow(nested)]`/`#[nested]`), better error messages.
- Preludes, re-exports, crate docs, examples.

---

## Testing Strategy
- Unit: type-to-Arrow mapping for each supported marker, nullability flags.
- Derive: generated `LEN`, names, `ColAt<I>` invariants.
- E2E: build `RecordBatch` from builders and verify with arrow-rs readers.
- Property: random null masks and values vs. arrow-rs invariants.

---

## Open Questions / Risks
- Timezones at type level: use const `&'static str` generic or a closed set of TZ types? Start with UTC only.
- Decimal overflow/scale enforcement in builders: enforce at append-time or constructor?
- Dictionary-encoded columns: how to expose keys/types at compile-time without specialization.
- Stable specialization: avoid it; prefer marker traits and explicit impls.
- Arrow-rs compatibility: gate features for versioned differences in array/builder APIs.

---

## Deliverables & Milestones
- M1: Core traits + derive + primitives/utf8/bool + runtime schema + batch finish.
- M2: Temporal/decimal/binary support + examples.
- M3: Compile-time dispatch utilities + example kernels.
- M4: Docs, polished API, ergonomic helpers, CI.

---

## Minimum Supported Rust Version (tentative)
- Rust 1.75+ (const generics for integers are sufficient; advance if we adopt additional const parameters).

---

## Next Steps
- Initialize `crates/core` and `crates/derive` with skeletons.
- Implement primitive mappings and `#[derive(Record)]` with `ColAt<I>/NullableAt<I>`.
- Land first E2E example building a `RecordBatch` from typed builders.

## Nested Types
- Support Struct, List/LargeList, FixedSizeList, Map (Dictionary optional; Union later) using natural Rust shapes (`Option`, `Vec`, arrays, nested `#[derive(Record)]`).
- Control nullability per level with `Option<_>`; item nullability via `Option<T>` in element type.
- Attributes: `#[arrow(list(large = bool))]`, `#[arrow(fixed_size_list)]`, `#[arrow(map(keys_sorted = bool))]`, `#[arrow(child(name = "..."))]`.
- Builders expose nested paths and container-aware APIs (`start/item/end`, `append_iter`, fixed-size append).
- Compile-time dispatch adds `LeafVisitor` and `for_each_leaf::<R, V>()` for monomorphized kernels over leaves.
- Details and examples: see `docs/nested-types.md`.
# Repository Guidelines

## Project Structure & Module Organization
- `src/` — core library:
  - `schema.rs`: `Record`, `ColAt<I>`, visitors, compile-time metadata.
  - `bridge.rs`: `ArrowBinding` (Rust type → Arrow builder/array/DataType).
  - `lib.rs`: crate entry, prelude exports.
- `arrow-native-derive/` — proc-macro crate implementing `#[derive(Record)]`.
- `tests/` — integration tests (e.g., `primitive_macro.rs`).
- `docs/` — design notes (e.g., `nested-types.md`).

## Build, Test, and Development Commands
- `cargo build` — builds the workspace (library + proc-macro).
- `cargo test` — runs unit and integration tests.
- `cargo check` — fast type-check of the workspace.
- Optional: `RUSTFLAGS='-D warnings' cargo build` to treat warnings as errors.

## Coding Style & Naming Conventions
- Rust 2021 edition; keep code idiomatic and minimal.
- Run `rustfmt` (standard Rust formatting). Use `clippy` locally for hints.
- Naming: modules `snake_case`, types and traits `CamelCase`, functions `snake_case`, constants `SCREAMING_SNAKE_CASE`.
- Public API docs: crate uses `#![deny(missing_docs)]` — document new public items.

## Testing Guidelines
- Prefer focused tests; add integration tests in `tests/` for end‑to‑end flows.
- Validate that `ColAt<I>` exposes `fn data_type()`, `ColumnBuilder`, `ColumnArray` and that builders produce typed arrays.
- Exercise row-based building (`append_row`, `append_option_rows`) and nested struct append (`#[arrow(nested)]`).
- Run locally with `cargo test -q` and `cargo clippy --workspace -D warnings`.

## Commit & Pull Request Guidelines
- Commits: clear, imperative mood (e.g., “Add ArrowBinding for u32”).
- Prefer small, focused commits with meaningful scope; reference issues when relevant.
- PRs must include:
  - What changed and why (problem statement + approach).
  - Tests or rationale for test coverage.
  - Notes on API or behavior changes (breaking/experimental).

## Architecture Overview
- Compile-time schema via `#[derive(Record)]` generates `Record`, `ColAt<I>`, and `ForEachCol`.
- `ColAt<I>` exposes `Rust` (inner type), `data_type()`, `ColumnBuilder`, and `ColumnArray` — no runtime `DataType` switching.
- `bridge::ArrowBinding` maps Rust types (e.g., `i64`, `String`, `Vec<u8>`, `List<T>`, `Timestamp<U>`, `Dictionary<K, String>`) to Arrow builders/arrays.
