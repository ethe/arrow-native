# Compile-Time Arrow Schema (arrow-rs) — Plan & Design

## TL;DR
- Provide a compile-time schema for Arrow using Rust types and macros.
- Generate monomorphized code per column index and base type (no runtime `DataType` switching).
- Bridge type-level schema to arrow-rs builders/arrays and to a runtime `Schema`/`RecordBatch` when needed.

---

## Goals
- Encode each column’s Arrow type and nullability at the type level via `#[derive(Record)]`.
- Enable compile-time dispatch across columns and base types using traits/const-generics (no `match DataType` at runtime).
- Generate typed Arrow builders/arrays for each column from the compile-time schema.
- Produce a runtime `arrow_schema::Schema` and `RecordBatch` from the compile-time schema when integration with arrow-rs is needed.
- Keep ergonomics close to idiomatic Rust: field attributes express Arrow specifics; Option/Nullability is explicit.

## Non-Goals (Initial Phases)
- Runtime reflection of arbitrary user types. The schema is compile-time and explicit.
- Note: Timezones are supported via `TimestampTz<U, Z>` (e.g., `Utc`).

---

## High-Level Architecture

### Type-Level Schema (Core)
- `#[derive(Record)]` on a plain Rust struct generates:
  - `impl Record for T` with `const LEN: usize`.
  - Per-column type metadata via `ColAt<I>` exposing `type Rust`, `type ColumnBuilder`, `type ColumnArray`, `const NULLABLE`, `const NAME`, and `fn data_type() -> DataType`.
  - A type-directed “for-each column” expansion hook via `ForEachCol::for_each_col`.

- Implemented traits (current):
  - `Record`, `ColAt<I>`, `ForEachCol`.
  - Row-based building: `BuildRows` with generated `<Type>Builders` and `<Type>Arrays`.
  - Nested struct support: `StructMeta` (child fields + struct builder) and `AppendStruct` (append children into a StructBuilder).

- Nullability:
  - Mode A: Use `Option<T>` in the field type.
  - Mode B: `#[arrow(nullable)]` attribute even if field type is non-`Option` (explicit override). Derived code maps to `NULLABLE` const.

### Arrow Interop (Runtime Bridge)
- Type mapping trait:
  - `trait ArrowBinding { type Builder; type Array: arrow_array::Array; fn data_type() -> DataType; ... }`
  - Implementations map Rust types directly to arrow-rs typed builders/arrays without runtime dispatch.

- Builders API (row-based):
  - `BuildRows` derive emits `<Type>Builders` and `<Type>Arrays`.
  - `<Type>Builders` methods: `append_row(row)`, `append_rows(iter)`, `append_null_row()`, `append_option_row(Option<row>)`, `append_option_rows(iter)`; `finish()` returns `<Type>Arrays`.
- Nested structs are supported via `#[record(nested)]` (preferred) and `#[nested]`, plus `AppendStruct`.
  - Future: optional `into_record_batch()` bridge when needed.

- Runtime schema:
  - Planned: `schema::<R>()` from `ColAt<I>`/`StructMeta` when integrating with RecordBatch.

- Compile-Time Dispatch (No runtime matches)
- Column visitor/iterator (generated by derive):
  - `trait ColumnVisitor { fn visit<const I: usize, R>(FieldMeta<R>); }`
  - `for_each_col::<V>()` expands to `V::visit::<I, Rust>(...)` for each column at compile time.
- Kernel pattern: implement `ColumnVisitor` for an operation; the monomorphized instances per column/base-type fall out of generics.

- Macro & Attribute Design
- `#[derive(Record)]` with field-level attributes:
  - `#[record(nested)]` (or legacy `#[nested]`) marks a struct-typed field as nested `Struct` for row-based append ergonomics.
- `#[derive(Union)]` (enums) supports Dense/Sparse modes and attributes:
  - Container: `#[union(mode = "dense"|"sparse", null_variant = "Var", tags(A=10, B=7))]`
  - Variant: `#[union(tag = 42)]`, `#[union(field = "name")]`, `#[union(null)]`
- Map uses wrappers rather than attributes: `Map<K, V, const SORTED: bool>` and `OrderedMap<K, V>`; value-nullability via `Option<V>`.
- Helper macro for column iteration (optional if derive emits trait impl):
  - `for_each_col!(RecordType, |I, Meta| { /* compile-time expanded body */ });`

### Ergonomics
- Default mapping for well-known Rust types:
  - `i8/i16/i32/i64`, `u8/u16/u32/u64`, `f32/f64`, `bool` map to Arrow primitives.
  - `String` → `Utf8`, `Vec<u8>` → `Binary`.
  - `Option<T>` toggles nullability at the column level.
- Nested & specialized wrappers (current):
- Lists: `List<T>` (items non-null), `List<Option<T>>` (items nullable); LargeList and FixedSizeList variants.
  - Dictionary: `Dictionary<K, V>` for Utf8/Binary/FixedSizeBinary/primitives.
  - Timestamp: `Timestamp<U>` (unit markers) and `TimestampTz<U, Z>` (timezone markers, e.g., `Utc`).
  - Decimal: `Decimal128<const P: u8, const S: i8>`, `Decimal256<const P: u8, const S: i8>`.
  - Map: `Map<K, V, const SORTED: bool>`; nullable values via `Option<V>`.
  - Ordered Map: `OrderedMap<K, V>` with sorted keys (`keys_sorted = true`).
  - Union: `#[derive(Union)]` with Dense and Sparse modes.

---

## Example

```rust
use typed_arrow::prelude::*;

#[derive(Record)]
struct Address { city: String, zip: Option<i32> }

#[derive(Record)]
struct Person {
    id: i64,
    #[nested]
    address: Option<Address>,
    email: Option<String>,
}

fn build_arrays_from_rows(rows: Vec<Option<Person>>) {
    let mut b = <Person as BuildRows>::new_builders(rows.len());
    b.append_option_rows(rows);
    let arrays = b.finish();
    // arrays.id: PrimitiveArray<Int64Type>
    // arrays.address: StructArray
    // arrays.email: StringArray
}

// Example compile-time dispatch
struct Count;
impl ColumnVisitor for Count {
    fn visit<const I: usize, R>(_m: FieldMeta<R>) {
        let _ = I;
    }
}
fn debug_schema<T: ForEachCol>() { T::for_each_col::<Count>(); }
```

---

## Open Questions / Risks
- Timezones at type level: use const `&'static str` generic or a closed set of TZ types? Start with UTC only.
- Decimal overflow/scale enforcement in builders: enforce at append-time or constructor?
- Dictionary-encoded columns: how to expose keys/types at compile-time without specialization.
- Stable specialization: avoid it; prefer marker traits and explicit impls.
- Arrow-rs compatibility: gate features for versioned differences in array/builder APIs.

---

## Minimum Supported Rust Version (tentative)
- Rust 1.75+ (const generics for integers are sufficient; advance if we adopt additional const parameters).

---

# Repository Guidelines

## Project Structure & Module Organization
- `src/` — core library:
  - `schema.rs`: `Record`, `ColAt<I>`, visitors, compile-time metadata.
  - `bridge.rs`: `ArrowBinding` (Rust type → Arrow builder/array/DataType).
  - `lib.rs`: crate entry, prelude exports.
- `typed-arrow-derive/` — proc-macro crate implementing `#[derive(Record)]` and `#[derive(Union)]`.
- `tests/` — integration tests (e.g., `primitive_macro.rs`).
- `docs/` — design notes (e.g., `nested-types.md`).
- `examples/` — runnable demos (e.g., `examples/11_map.rs`).

## Build, Test, and Development Commands
- `cargo build` — builds the workspace (library + proc-macro).
- `cargo test` — runs unit and integration tests.
- `cargo check` — fast type-check of the workspace.
- Optional: `RUSTFLAGS='-D warnings' cargo build` to treat warnings as errors.

## Coding Style & Naming Conventions
- Rust 2021 edition; keep code idiomatic and minimal.
- Run `rustfmt` (standard Rust formatting). Use `clippy` locally for hints.
- Naming: modules `snake_case`, types and traits `CamelCase`, functions `snake_case`, constants `SCREAMING_SNAKE_CASE`.
- Public API docs: crate uses `#![deny(missing_docs)]` — document new public items.

## Testing Guidelines
- Prefer focused tests; add integration tests in `tests/` for end‑to‑end flows.
- Validate that `ColAt<I>` exposes `fn data_type()`, `ColumnBuilder`, `ColumnArray` and that builders produce typed arrays.
- Exercise row-based building (`append_row`, `append_option_rows`) and nested struct append (`#[nested]`).
- Validate DataType shapes (child names, `keys_sorted`, union tags/fields) and append semantics.
- Prefer names/tags over child indices when asserting nested/union children.
- Run locally with `cargo test -q` and `cargo clippy --workspace -D warnings`.

## Commit & Pull Request Guidelines
- Commits: clear, imperative mood (e.g., “Add ArrowBinding for u32”).
- Prefer small, focused commits with meaningful scope; reference issues when relevant.
- PRs must include:
  - What changed and why (problem statement + approach).
  - Tests or rationale for test coverage.
  - Notes on API or behavior changes (breaking/experimental).

## Architecture Overview
- Compile-time schema via `#[derive(Record)]` generates `Record`, `ColAt<I>`, and `ForEachCol`.
- `ColAt<I>` exposes `Rust` (inner type), `data_type()`, `ColumnBuilder`, and `ColumnArray` — no runtime `DataType` switching.
- `bridge::ArrowBinding` maps Rust types and wrappers (e.g., primitives, Utf8/Binary, List/LargeList/FixedSizeList, Map/OrderedMap, Decimal128/256, Timestamp/TimestampTz, Dictionary, and Union via derive) to Arrow builders/arrays.
